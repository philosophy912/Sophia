# -*- coding:utf-8 -*-
# -------------------------------------------------------------------------------
#  Copyright (C), 2016-2020, China TSP, All rights reserved
# -------------------------------------------------------------------------------
# Name:        ${fileName}.py
# Purpose:     The file is automatically generated by tools.
# Author:      CD QA Team
# Created:     ${createDate}
# -------------------------------------------------------------------------------
import copy
from automotive import CANService, Message
from ${projectName}.config.${projectName} import messages
from loguru import logger


class Service(CANService):

    def __init__(self):
        super().__init__(messages)
        # 备份原始数据，作为初始值发送
        self.__messages = copy.deepcopy(self.messages)

    def __set_message(self, msg_id: int, data: list) -> Message:
        """
        :param msg_id:
        :param data:
        :return:
        """
        msg = self.messages[msg_id]
        msg.data = data
        msg.update(False)
        return msg

    def send_messages(self):
        for msg_id, message in self.messages.items():
            self.send_can_message(message)

    def send_default_messages(self):
        for msg_id, message in self.__messages.items():
            if message.sender != "FCP" and msg_id != 0x232:
                self.send_can_message(message)

    def check_signal_value(self, stack: list, msg_id: int, sig_name: str, expect_value: int, count: int = None,
                               exact: bool = True):
            """
            检查signal的值是否符合要求
            :param exact: 是否精确对比
            :param msg_id: msg id
            :param sig_name:  sig name
            :param expect_value: expect value
            :param count: 检查数量
            :param stack: 栈中消息
            """
            if count:
                # 过滤需要的msg
                filter_messages = list(filter(lambda x: x.msg_id == msg_id, stack))
                logger.debug(f"filter messages length is {len(filter_messages)}")
                msg_count = 0
                for msg in filter_messages:
                    logger.debug(f"msg data = {msg.data}")
                    # 此时的msg只有data，需要调用方法更新内容
                    message = self.__set_message(msg.msg_id, msg.data)
                    actual_value = message.signals[sig_name].physical_value
                    logger.debug(f"actual_value = {actual_value}")
                    if actual_value == expect_value:
                        msg_count += 1
                logger.info(f"except count is {count}, actual count = {msg_count}")
                if exact:
                    return msg_count == count
                else:
                    return msg_count >= count
            else:
                # 直接读取can上的最后的值
                actual_value = self.receive_can_message_signal_value(msg_id, sig_name)
                logger.info(f"current value is {actual_value}, expect value is {expect_value}")
                return expect_value == actual_value
