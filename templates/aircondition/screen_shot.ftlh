# -*- coding:utf-8 -*-
# -------------------------------------------------------------------------------
#  Copyright (C), 2016-2020, China TSP, All rights reserved
# -------------------------------------------------------------------------------
# Name:        ${fileName}.py
# Purpose:     The file is automatically generated by tools.
# Author:      CD QA Team
# Created:     ${createDate}
# -------------------------------------------------------------------------------
from time import sleep
from loguru import logger
from automotive import SerialPort, Utils


class ScreenShot(object):
    """
    适用于1Q1的截屏
    """

    def __init__(self, port: str):
        """
            初始化
            @:param port 串口号
        """
        # 保存到板子上面的log
        self.__save_path = "/var/screenshot"
        # 设置串口
        self.__serial = SerialPort()
        # 端口
        self.__port = port.upper()
        # 串口连接状态
        self.__status = False

    def check_status(func):
        """
        检查设备是否已经连接
        :param func: 装饰器函数
        """

        def wrapper(self, *args, **kwargs):
            if not self.__status:
                raise RuntimeError("请先连接串口，并确保端口可用")
            return func(self, *args, **kwargs)

        return wrapper

    def __init_serial(self):
        if not self.__status:
            try:
                self.__serial.connect(self.__port, baud_rate=115200)
                self.__status = True
            except RuntimeError:
                logger.error(f"connect failed in {self.__port}")

    @check_status
    def __send_command(self, command: str):
        """
        发送命令到串口
        :param command: 命令
        """
        logger.debug(f"command is {command}")
        self.__serial.send(command, type_=True)

    def __send_commands(self, commands: list, interval: float = 0):
        """
        发送多条命令到串口
        :param commands: 命令列表
        :param interval: 命令之间的间隔时间
        """
        for command in commands:
            self.__send_command(command)
            sleep(interval)

    def __press(self, display: int, x: int, y: int, continue_time: float = 0.2):
        """
        点击或者长按
        :param display: 屏幕
        :param x: x坐标
        :param y: y坐标
        :param continue_time: 持续时间， 默认点击事件0.2秒
        """
        press = f"echo \"{display} 1 {x} {y}\" > /dev/inject_events"
        release = f"echo \"{display} 3 {x} {y}\" > /dev/inject_events"
        commands = [press, release]
        self.__send_commands(commands, continue_time)

    @staticmethod
    def __get_area(area) -> tuple:
        if area == 1:
            return Utils.random_int(5, 5 + 1263), Utils.random_int(544, 544 + 174)
        elif area == 2:
            return Utils.random_int(0, 1269), Utils.random_int(51, 51 + 88)
        elif area == 3:
            return Utils.random_int(63, 63 + 1153), Utils.random_int(150, 150 + 376)
        else:
            return Utils.random_int(0, 1920), Utils.random_int(0, 720)

    def __prepare_folder(self):
        """
        删除原来的文件夹，并创建新的文件夹
        """
        commands = ["mount -uw /",
                    f"rm -rvf {self.__save_path}",
                    f"mkdir {self.__save_path}"]
        self.__send_commands(commands)

    def __prepare_inject_events(self):
        """
        准备运行InjectEvents &
        todo 需要判断是否已经启动过了
        """
        commands = ["slay InjectEvents",
                    "cd /usr/bin",
                    "./InjectEvents &",
                    "cd -"]
        self.__send_commands(commands, 2)

    def prepare(self):
        """
        准备
        """
        self.__prepare_folder()
        self.__prepare_inject_events()
	
    def __check_copy_status(self):
        """:arg
        检查copy文件是否完成
        """
        flag = True
        i = 1
        while flag:
            logger.info("copy is processing")
            i += 1
            self.__serial.flush_output()
            command = f"pidin | grep cp"
            self.__send_command(command)
            results = self.__serial.read_lines()
            logger.debug(f"第{i}次结果{results}")
            for result in results:
                if "Done" in result:
                    flag = False
            sleep(1)
        logger.info("copy is finished")
		
    def copy_file(self):
        current_time = Utils.get_time_as_string("%Y%m%d%H%M%S")
        usb_path = "/fs/usb0"
        screenshot_path = f"{usb_path}/screenshot"
        current_time_path = f"{screenshot_path}/{current_time}"
        commands = [
            f"mkdir {screenshot_path}",
            f"rm -rvf {current_time_path}",
            f"mkdir {current_time_path}",
            f"cp {self.__save_path}/* {current_time_path}/ &"
            f"sync"
        ]
        self.__send_commands(commands, 1)
        self.__check_copy_status()

    def connect(self):
        """
        做好一切准备工作
        """
        if not self.__status:
            try:
                self.__serial.connect(self.__port, baud_rate=115200)
                self.__status = True
            except RuntimeError:
                logger.error(f"connect failed in {self.__port}")

    def disconnect(self):
        """
        断开串口连接
        """
        self.__serial.disconnect()

    @check_status
    def click(self, display: int, x: int, y: int, interval: float = 0.2):
        """
        点击某个坐标点
        :param interval: 点击间隔时间，默认0.2秒
        :param x: x坐标
        :param y: y坐标
        :param display: 屏幕
        """
        logger.info(f"click display {display} position[{x},{y}]")
        self.__press(display, x, y, interval)

    @check_status
    def press(self, display: int, x: int, y: int, continue_time: float):
        """
        点击某个坐标点
        :param x: x坐标
        :param y: y坐标
        :param display: 屏幕
        :param continue_time: 持续时间
        """
        logger.info(f"press display {display} position[{x},{y}], continue time is {continue_time} ")
        self.__press(display, x, y, continue_time)

    @check_status
    def slide(self, display: int, x1: int, y1: int, x2: int, y2: int, continue_time: float):
        """
        滑动操作，只支持x1=x2的纵向滑动和y1=y2的横向滑动
        :param display: 屏幕
        :param x1: 起始点x坐标
        :param y1: 起始点Y坐标
        :param x2: 终结点x坐标
        :param y2: 终结点Y坐标
        :param continue_time:持续时间
        """
        logger.info(f"slide display[{display}] from {x1}, {y1} to {x2} {y2} use time {continue_time}")
        commands = []
        # 持续时间如果大于0.1秒则按照此公式计算，如果小于0.1秒则按照实际的时间来计算
        if continue_time > 0.1:
            time = int(continue_time / 0.1)
            if x1 == x2:
                # 纵向滑动
                # 计算滑动的距离
                height = abs(y2 - y1)
                interval_height = int(height / time)
                for i in range(time):
                    if i == 0:
                        command = f"echo \"{display} 1 {x1} {y1}\" > /dev/inject_events"
                    elif i == time - 1:
                        command = f"echo \"{display} 3 {x1} {y2}\" > /dev/inject_events"
                    else:
                        # 上滑
                        if y2 > y1:
                            command = f"echo \"{display} 2 {x1} {y1 + i * interval_height}\" > /dev/inject_events"
                        else:
                            command = f"echo \"{display} 2 {x1} {y1 - i * interval_height}\" > /dev/inject_events"
                    commands.append(command)
            elif y1 == y2:
                # 横向滑动
                width = abs(x2 - x1)
                interval_width = int(width / time)
                for i in range(time):
                    if i == 0:
                        command = f"echo \"{display} 1 {x1} {y1}\" > /dev/inject_events"
                    elif i == time - 1:
                        command = f"echo \"{display} 3 {x1} {y2}\" > /dev/inject_events"
                    else:
                        if x2 > x1:
                            command = f"echo \"{display} 2 {x1 + i * interval_width} {y1}\" > /dev/inject_events"
                        else:
                            command = f"echo \"{display} 2 {x1 - i * interval_width} {y1}\" > /dev/inject_events"
                    commands.append(command)
            else:
                raise RuntimeError(f"x1[{x1}] is not equal x2[{x2}] or y1[{y1}] is not equal y2[{y2}]")
            self.__send_commands(commands, 0.1)
        else:
            if x1 == x2:
                command1 = f"echo \"{display} 1 {x1} {y1}\" > /dev/inject_events"
                command2 = f"echo \"{display} 3 {x1} {y2}\" > /dev/inject_events"
            elif y1 == y2:
                command1 = f"echo \"{display} 1 {x1} {y1}\" > /dev/inject_events"
                command2 = f"echo \"{display} 3 {x1} {y2}\" > /dev/inject_events"
            else:
                raise RuntimeError(f"x1[{x1}] is not equal x2[{x2}] or y1[{y1}] is not equal y2[{y2}]")
            commands.append(command1)
            commands.append(command2)
            self.__send_commands(commands, continue_time)

    @check_status
    def screen_shot(self, display: int, image_name: str):
        """
        屏幕截图
        :param display: 屏幕
        :param image_name: 要截图的图片名称
        """
        file = f"{self.__save_path}/{image_name}.bmp"
        command = f"screenshot -display={display} -file={file}"
        logger.info(f"screenshot file is [{file}]")
        self.__send_command(command)

    @check_status
    def random_click(self, display: int, cycle_time: int, interval: float = 0.2, click_interval: float = 0.2):
        """
        随机点击屏幕
        :param click_interval: 按下和弹起间隔时间
        :param interval: 间隔时间
        :param display: 屏幕
        :param cycle_time: 点击次数
        """
        for i in range(cycle_time):
            area = Utils.random_int(0, 4)
            logger.info(f"now the {i + 1}'s click, area is {area}")
            x, y = self.__get_area(area)
            self.click(display, x, y, click_interval)
            sleep(interval)
        self.disconnect()

    @check_status
    def login(self, user: str, password: str):
        """
        检查串口是否需要输入用户名和密码登录，如需要则输入
        :param user: 用户名
        :param password: 密码
        """
        login_word = "login"
        pass_word = "Password"
        self.__serial.flush_output()
        self.__serial.send("\r\n")
        sleep(1)
        serial_output_login = self.__serial.read_all()
        if login_word in serial_output_login:
            logger.debug(f"输入登录用户名{user}")
            self.__serial.send(user)
            sleep(1)
            serial_output_pass = self.__serial.read_all()
            if pass_word in serial_output_pass:
                logger.debug(f"输入登录密码{password}")
                self.__serial.send(password)
